#suources:
# https://devices.esphome.io/devices/sinilink-xy-wpce/
# https://karlquinsland.com/esphome-sinilink-pc-remotes/
# pinout
# https://templates.blakadder.com/sinilink_XY-WPCL.html

substitutions:
  friendly_name: "Server Power Control"
  friendly_name_short: "Server"
  hostname: "serv-power"

esphome:
  name: ${hostname}
  on_boot:
    - priority: -200
      then:
        - switch.turn_off: relay_sw
    - priority: 200
      then:
        - globals.set:
            id: glbl_relay_latched
            value: "true"

esp8266:
  board: esp8285

# Enable logging
logger:


# Enable Home Assistant API
api:
  encryption:
    key: "LiXOuqbRkczstEjW/GqmPz+eUAtQ8Wov8AUypkjTNt0="
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: "2867d6f286e36ee0de94cbcb43ff05ec"
#    reboot_timeout: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA2

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Serv-Ctrl Fallback Hotspot"
    password: "qweqwe123"

captive_portal:
    
web_server:
  port: 80
  version: 3

globals:
  - id: glbl_relay_latched
    type: bool
    restore_value: yes
    initial_value: "true"

button:
  - platform: safe_mode
    name: "$friendly_name Restart (Safe Mode)"
  - platform: restart
    name: "$friendly_name board Restart"
    entity_category: "diagnostic"
  # We expose a button to the HA web UI that mimics the "forceful" power down sequence

  - name: "${friendly_name_short} Long Press"
    id: btn_forceful_down
    platform: template
    on_press:
      - lambda: |-
          // If the power state is off, we'll emit a WARN level message before running the script
          if( !id(inp_power_status).state ){
            ESP_LOGW("forcefulShutdown", "Power state is OFF but forceful shutdown requested...");
          } else {
            ESP_LOGW("forcefulShutdown", "Power state is ON. Forceful shutdown requested...");
          }
          id(long_press).execute();


script:
  - id: regular_press
    mode: single
    then:
      - switch.turn_on: relay_sw
      - delay: 500ms
      - switch.turn_off: relay_sw
  - id: long_press
    mode: single
    then:
      - switch.turn_on: relay_sw
      - delay: 7s
      - switch.turn_off: relay_sw


status_led:
  pin:
    number: GPIO02
    inverted: True

binary_sensor:
  - name: "${friendly_name} WiFi Config Button"
  #nic nie robi, tylko jest
    platform: gpio
    id: inp_wifi_cfg_btn
    entity_category: "diagnostic"
    icon: "mdi:radiobox-marked"
    pin:
      number: GPIO04
      mode: INPUT_PULLUP
      inverted: True

  - name: "${friendly_name} Power Status"
  # sygnał chyba z PowerLED
    platform: gpio
    id: inp_power_status
    device_class: "power"
    entity_category: "diagnostic"
    icon: "mdi:power-settings"
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: True

  - name: "${friendly_name} Case Button"
  # sygnał pochodzi z klawisza z obudowy
    platform: gpio
    id: inp_pc_case_btn_status
    entity_category: "diagnostic"
    icon: "mdi:power-standby"
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: True

    # To accurately mimic the "button wired directly to motherboard" function, use on_press/on_release
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(glbl_relay_latched);'
            then:
              - switch.turn_on: relay_sw
            else:
              - logger.log: "PC Case button press but disarmed!"
    on_release:
      then:
        - if:
            condition:
              lambda: 'return id(glbl_relay_latched);'
            then:
              - switch.turn_off: relay_sw
            else:
              - logger.log: "PC Case button release but disarmed!"

    # To implement more sophisticated functionality like the "lock out" mode in the OEM firmware
    #   use on_click.
    on_click:
      then:
        - lambda: |-
            // If relay isn't latched, do nothing
            if( !id(glbl_relay_latched) ){
              ESP_LOGD("caseBtnPress", "button pressed, not latched so doing nothing.");
              return;
            }
            ESP_LOGD("caseBtnPress", "button pressed, latched. Toggling power now...");
            id(sw_pc_power).toggle();

    on_multi_click:
    - timing:
        - ON for at most 1s
        - OFF for at most 2s
        - ON for at most 1s
        - OFF for at most 2s
        - ON for at most 1s
        - OFF for at most 2s
      then:
        # We'd want to press a virtual / template button for hard power down
        # That template button would run a script that just raised the output hight for 10s
        - logger.log: "Triple clicked!"
        - button.press: btn_forceful_down

switch:
  - name: "${friendly_name_short} Power"
    id: sw_pc_power
    platform: template
    icon: "mdi:power-plug"
    device_class: "switch"
    lambda: |-
      if (id(inp_power_status).state) {
        return true;
      } else {
        return false;
      }

    # Mimic the user pressing the button
    turn_on_action:
      - script.execute: regular_press
    turn_off_action:
      - script.execute: regular_press

  - name: "${friendly_name_short} Relay Latch"
    platform: template
    id: sw_relay_mode
    device_class: "switch"
    icon: "mdi:link-variant"
    entity_category: "config"

    lambda: |-
      if (id(glbl_relay_latched)) {
        return true;
      } else {
        return false;
      }

    turn_on_action:
      - globals.set:
          id: glbl_relay_latched
          value: "true"

    turn_off_action:
      - globals.set:
          id: glbl_relay_latched
          value: "false"


#switch:
  - platform: gpio
    id: relay_sw
    pin:
      number: GPIO5
      mode: OUTPUT
    inverted: true
    restore_mode: ALWAYS_OFF
    internal: true

#output:
#  - platform: gpio
#    id: out_relay
#    pin:
#      number: GPIO5
#      mode: OUTPUT
#    inverted: true
#    restore_mode: ALWAYS_OFF
