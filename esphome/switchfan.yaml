substitutions:
  friendly_name: "Switch FAN"

esphome:
  name: switchfan
  friendly_name: switchfan
  on_boot:
    priority: 250
    then:
      - fan.turn_on:
            id: pwm_fan
            speed: 20
      - script.execute: update_fan_by_temp

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "unuNWrQ76o1ydnuHdNE3DJZXCD1Homy24/XKc/61NMs="
  reboot_timeout: 0s
ota:
  - platform: esphome
    password: "502d344dbad6ceeb14d7a74d339fab6e"
captive_portal:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Switchfan Fallback Hotspot"
    password: "twcE83mGs7uk"

web_server:
  port: 80
  version: 3


# ------------- I2C + CZUJNIKI -------------

i2c:
  sda: GPIO6
  scl: GPIO7
  scan: true

sensor:
  # BMP280 – temperatura + ciśnienie
  - platform: bmp280_i2c
    address: 0x77
    temperature:
      name: "Fan Box Temperature"
      id: temp_bmp
      oversampling: 16x
    pressure:
      name: "Fan Box Pressure"
      id: press_bmp
    update_interval: 30s

  # AHT20 – temperatura + wilgotność
  - platform: aht10
    variant: AHT20
    temperature:
      name: "Fan Box Temperature AHT20"
      id: temp_aht
    humidity:
      name: "Fan Box Humidity"
      id: hum_aht
    update_interval: 30s

  # TACH-IN z wentylatora (pin 3 FAN) -> GPIO4
  - platform: pulse_counter
    id: fan_rpm_real
    name: "Fan RPM (real)"
    pin:
      number: GPIO4
      mode:
        input: true
        pullup: true
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    update_interval: 2s
    unit_of_measurement: "rpm"
    accuracy_decimals: 0
    filters:
      - multiply: 0.5      # 2 impulsy na obrót
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(tach_mode_real);'
            then:
              - lambda: |-
                  id(tach_target_rpm) = x;
              - script.execute: update_tach_pwm

  # opcjonalnie: podgląd aktualnie zadanej RPM dla TACH-OUT
  - platform: template
    id: tach_target_rpm_sensor
    name: "Tach Target RPM"
    unit_of_measurement: "rpm"
    accuracy_decimals: 0
    update_interval: 2s
    lambda: |-
      return id(tach_target_rpm);


# pomiary urządzenia
  - platform: wifi_signal
    name: "$friendly_name WiFi Signal"
    update_interval: 60s

# pomiary urządzenia
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "$friendly_name IP Address"
    ssid:
      name: "$friendly_name Connected SSID"
    bssid:
      name: "$friendly_name Connected BSSID"
    mac_address:
      name: "$friendly_name Mac Wifi Address"
  - platform: version
    name: "ESPHome Version"
    hide_timestamp: true

# ------------- GLOBALS (logika TACH) -------------

globals:
  # RPM, z której generujemy TACH-OUT
  - id: tach_target_rpm
    type: float
    initial_value: '0.0'

  # tryb pracy tach-out: true = REAL, false = SIMULATED
  - id: tach_mode_real
    type: bool
    restore_value: yes
    initial_value: 'true'

# ------------- WYJŚCIA (PWM FAN + TACH) -------------

output:
  # PWM sterujący wentylatorem 4-pin (pin 4 PWM wiatraka przez IRF/NPN – to już masz)
  - platform: ledc
    id: fan_pwm
    pin: GPIO5
    frequency: 25000 Hz
    #inverted: true          # żeby 0% = stop, 100% = max
    min_power: 0.0          # 50–100% zakres pracy
    max_power: 1.0
    #zero_means_zero: true   # 0% = naprawdę wyłączony

  # TACH-OUT na płytę – GPIO9 -> baza NPN
  # NPN w konfiguracji open-collector, kolektor na pin TACH-IN płyty
  - platform: ledc
    id: tach_pwm
    pin: GPIO10
    frequency: 50 Hz        # wartość startowa, potem zmieniamy runtime
    channel: 2              # inny kanał niż fan_pwm, żeby nie dzieliły timera

# ------------- FAN – encja w HA -------------

fan:
  - platform: speed
    name: "PWM Fan"
    id: pwm_fan
    output: fan_pwm
    speed_count: 50   # 20 kroków, co 5%

# ------------- TRYB TACH: REAL / SIMULATED -------------

select:
  - platform: template
    name: "Tach Output Mode"
    id: tach_mode_select
    optimistic: true
    restore_value: true
    options:
      - "real"
      - "simulated"
    initial_option: "real"
    set_action:
      - lambda: |-
          if (x == "real") {
            id(tach_mode_real) = true;
            // jeśli jest sensowny odczyt z realnego TACH-IN, użyj go
            if (!isnan(id(fan_rpm_real).state)) {
              id(tach_target_rpm) = id(fan_rpm_real).state;
            }
          } else {
            id(tach_mode_real) = false;
            // przy przejściu na simulated od razu weź wartość z suwaka
            if (!isnan(id(sim_fan_rpm).state)) {
              id(tach_target_rpm) = id(sim_fan_rpm).state;
            }
          }
      - script.execute: update_tach_pwm

# ------------- SUWAKI (RPM symulowane + progi temperatury dla auto-FAN) -------------

# Slider do RPM w trybie symulowanym
number:
  - platform: template
    name: "Simulated Fan RPM"
    id: sim_fan_rpm
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 4000
    step: 50
    unit_of_measurement: "rpm"
    set_action:
      - if:
          condition:
            lambda: 'return !id(tach_mode_real);'
          then:
            - lambda: |-
                id(tach_target_rpm) = x;
            - script.execute: update_tach_pwm

  # Minimalna temperatura: poniżej -> pwm_fan OFF (speed 0)
  - platform: template
    name: "Fan Temp Min"
    id: fan_temp_min
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 60
    step: 0.5
    unit_of_measurement: "°C"
    initial_value: 25
    set_action:
      - script.execute: update_fan_by_temp

  # Maksymalna temperatura: od niej -> pwm_fan speed 20
  - platform: template
    name: "Fan Temp Max"
    id: fan_temp_max
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 80
    step: 0.5
    unit_of_measurement: "°C"
    initial_value: 45
    set_action:
      - script.execute: update_fan_by_temp

# ------------- POMIARY URZĄDZENIA -------------

switch:
  - platform: restart
    name: "$friendly_name - Restart"

  - platform: template
    name: "$friendly_name - Auto Fan Control"
    id: auto_fan_control
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:fan-auto"
    on_turn_on:
      - script.execute: update_fan_by_temp



# pomiary urządzenia
binary_sensor:
  - platform: status
    name: "$friendly_name Status"


interval:
  - interval: 10s
    then:
      - if:
          condition:
            switch.is_on: auto_fan_control
          then:
            - script.execute: update_fan_by_temp

# ------------- SKRYPT: aktualizacja PWM dla TACH-OUT -------------

script:
  - id: update_tach_pwm
    then:
      - if:
          condition:
            lambda: 'return id(tach_target_rpm) < 10.0f;'
          then:
            - output.set_level:
                id: tach_pwm
                level: 0%
          else:
            # RPM > 10 -> ustaw 50% duty i częstotliwość = RPM * 2 / 60
            - lambda: |-
                float rpm = id(tach_target_rpm);
                float pps = rpm * 2.0f / 60.0f;   // pulses per second
                if (pps < 1.0f) pps = 1.0f;
                id(tach_pwm).set_frequency(pps);
            - output.set_level:
                id: tach_pwm
                level: 50%


  # AUTOMATYKA: temperatura -> sterowanie pwm_fan (speed 0..20)
  - id: update_fan_by_temp
    mode: restart
    then:
      - lambda: |-
          // 1) Sprawdź, czy automatyka włączona (dodatkowa asekuracja)
          if (!id(auto_fan_control).state) return;

          // 2) Źródło temperatury
          float t = id(temp_bmp).state;

          float t_min = id(fan_temp_min).state;
          float t_max = id(fan_temp_max).state;

          if (isnan(t) || isnan(t_min) || isnan(t_max)) return;

          // zabezpieczenie przed błędną konfiguracją progów
          if (t_max <= t_min + 0.1f) t_max = t_min + 0.1f;

          // 3) Mapowanie temp -> speed 0..50
          int speed = 0;

          if (t <= t_min) {
            speed = 0;
          } else if (t >= t_max) {
            speed = 50;
          } else {
            float k = (t - t_min) / (t_max - t_min);   // 0..1
            speed = (int) lroundf(k * 50.0f);          // 0..50
            if (speed < 0) speed = 0;
            if (speed > 50) speed = 50;
          }

          // 4) Sterowanie WYŁĄCZNIE pwm_fan
          if (speed <= 0) {
            id(pwm_fan).turn_off();
          } else {
            auto call = id(pwm_fan).make_call();
            call.set_state(true);
            call.set_speed(speed);
            call.perform();
          }

